#!/opt/local/bin/perl
#
# A command line slack client.
# SSL errors require Crypt::SSLeay, so we include it here.
#
use warnings;
use strict;
use FindBin '$Bin';
use lib "$Bin/";
use Slack;
use threads;
use Term::ReadLine;
use Term::ANSIColor 2.00 qw(:pushpop);
use Getopt::Long qw(:config no_ignore_case require_order);

my $usage = <<"";
Usage: $0 [options] -- cmd args...
Options:
  -v | --verbose         Print debugging info on packets
  -t | --token token     Authorization token (default is to read from file)
  -c | --channel id      Channel ID (required)
  -l | --list-channels   List channels
  -u | --user name       User name to use as a bot
  -i | --interval secs   Time between polls (default 0.5 seconds)
  -I | --ignore RE       Regular expression to ignore on commands
  -F | --filter RE       Regular expression to apply to output from command
  -s | --stdin           Read/write from stdin/stdout instead of a command

my $log = \*STDERR;
my $base_url = "https://slack.com/api";
my $token;
my $channel;
my $user;
my $filter;
my @ignore;
my $sleep_interval = 0.5;
my $use_stdin;
my $print_user;
my $list_channels;
my $verbose;

GetOptions(
	"t|token=s"	=> \$token,
	"c|channel=s"	=> \$channel,
	"l|list-channels+" => \$list_channels,
	"u|username=s"	=> \$user,
	"i|interval=f"	=> \$sleep_interval,
	"I|ignore=s"	=> \@ignore,
	"F|filter=s"	=> \$filter,
	"s|stdin+"	=> \$use_stdin,
	"v|verbose+"	=> \$verbose,
	"h|?|help"	=> sub { print $usage; exit 0; },
) or die $usage;

# Read the token from a file, unless it was specified on the command line
$token ||= do "$Bin/slack.token";

my $s = Slack->new($token, $user)
	or die "Unable to create slack\n";

die "Channel must be specified!\n"
	unless defined $channel;

$s->{channel} = $s->channels()->{$channel}
	or die "$channel: unknown channel\n";


my $term = Term::ReadLine->new("slack");
my $listener = new threads( \&listener );

my $saved_point;
my $saved_line;

sub rl_hide
{
	$saved_point = $term->{point};
	$saved_line  = $term->{line_buffer};

	$term->rl_set_prompt("");
	$term->{line_buffer} = "";
	$term->rl_redisplay;
}

sub rl_show
{
	if (defined $saved_point) {
		$term->rl_set_prompt("> ");
		$term->{line_buffer} = $saved_line;
		$term->{point}       = $saved_point;
		$term->redisplay;
	}
}

sub listener
{
	warn "waiting for messages\n";
	while (1)
	{
		sleep($sleep_interval);

		my @lines = $s->messages()
			or next;

		rl_hide();
		for my $line (@lines)
		{
			print LOCALCOLOR YELLOW "$line->[0]: ";

			# filter the text
			local $_ = $line->[1];

			# replace entities
			s/&lt;/>/msg;

			# replace the user names
			s/<\@(U[^>]*)>/LOCALCOLOR BOLD "@".$s->uid2user($1)/msge;
				
			print "$_\n";
		}

		# ask readline to redisplay
		#$term->redisplay();
		rl_show();
	}
}

my $prompt = "> ";
$s->users();

sub find_user
{
	my $user = shift;

	for my $uid (keys %{$s->{users}})
	{
		next unless $s->{users}{$uid} eq $user;
		return "<\@$uid>";
	}

	return "\@$user";
}

warn "Waiting for input\n";
while( defined(my $line = $term->readline($prompt)) )
{
	# attempt to find any usernames
	$line =~ s/\@(\w+)/find_user($1)/msge;

	$s->send($line);
}   

__END__
